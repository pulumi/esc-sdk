# coding: utf-8

# Copyright 2024, Pulumi Corporation.  All rights reserved.

"""
    ESC (Environments, Secrets, Config) API

    Pulumi ESC allows you to compose and manage hierarchical collections of configuration and secrets and consume them in various ways.

    The version of the OpenAPI document: 0.1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class EscSchemaSchema(BaseModel):
    """
    EscSchemaSchema represents a JSON Schema used to describe the shape of environment values.
    """ # noqa: E501
    defs: Optional[Dict[str, Any]] = Field(default=None, description="Schema definitions that can be referenced by $ref.", alias="_defs")
    ref: Optional[StrictStr] = Field(default=None, description="A JSON reference to a schema definition.", alias="_ref")
    additional_properties: Optional[Any] = Field(default=None, description="The schema for additional object properties.", alias="additionalProperties")
    any_of: Optional[List[Any]] = Field(default=None, description="A list of schemas, any of which the value must match.", alias="anyOf")
    const: Optional[Any] = Field(default=None, description="A constant value the instance must equal.")
    default: Optional[Any] = Field(default=None, description="The default value for the schema.")
    dependent_required: Optional[Dict[str, List[StrictStr]]] = Field(default=None, description="A map of property names to lists of properties they depend on.", alias="dependentRequired")
    deprecated: Optional[StrictBool] = Field(default=None, description="Whether the schema is deprecated.")
    description: Optional[StrictStr] = Field(default=None, description="A human-readable explanation of the schema's purpose (JSON Schema annotation).")
    enum: Optional[List[Any]] = Field(default=None, description="A list of allowed values.")
    examples: Optional[List[Any]] = Field(default=None, description="Example values for the schema.")
    exclusive_maximum: Optional[StrictStr] = Field(default=None, description="The maximum allowed value (exclusive).", alias="exclusiveMaximum")
    exclusive_minimum: Optional[StrictStr] = Field(default=None, description="The minimum allowed value (exclusive).", alias="exclusiveMinimum")
    items: Optional[Any] = Field(default=None, description="The schema for array items.")
    max_items: Optional[StrictStr] = Field(default=None, description="The maximum number of items in an array.", alias="maxItems")
    max_length: Optional[StrictStr] = Field(default=None, description="The maximum allowed string length.", alias="maxLength")
    max_properties: Optional[StrictStr] = Field(default=None, description="The maximum number of properties in an object.", alias="maxProperties")
    maximum: Optional[StrictStr] = Field(default=None, description="The maximum allowed value (inclusive).")
    min_items: Optional[StrictStr] = Field(default=None, description="The minimum number of items in an array.", alias="minItems")
    min_length: Optional[StrictStr] = Field(default=None, description="The minimum allowed string length.", alias="minLength")
    min_properties: Optional[StrictStr] = Field(default=None, description="The minimum number of properties in an object.", alias="minProperties")
    minimum: Optional[StrictStr] = Field(default=None, description="The minimum allowed value (inclusive).")
    multiple_of: Optional[StrictStr] = Field(default=None, description="The value must be a multiple of this number.", alias="multipleOf")
    one_of: Optional[List[Any]] = Field(default=None, description="A list of schemas, exactly one of which the value must match.", alias="oneOf")
    pattern: Optional[StrictStr] = Field(default=None, description="A regular expression pattern the string must match.")
    prefix_items: Optional[List[Any]] = Field(default=None, description="Schemas for the leading items in an array.", alias="prefixItems")
    properties: Optional[Dict[str, Any]] = Field(default=None, description="Schemas for named object properties.")
    required: Optional[List[StrictStr]] = Field(default=None, description="The list of required property names.")
    rotate_only: Optional[List[StrictStr]] = Field(default=None, description="Pulumi ESC extension: property paths within this schema that support rotation-only updates.", alias="rotateOnly")
    secret: Optional[StrictBool] = Field(default=None, description="Pulumi ESC extension: if true, the value should be treated as sensitive and masked in output.")
    title: Optional[StrictStr] = Field(default=None, description="A short human-readable label for the schema (JSON Schema annotation).")
    type: StrictStr = Field(description="The type of the schema (e.g. string, number, object, array, boolean).")
    unique_items: Optional[StrictBool] = Field(default=None, description="Whether array items must be unique.", alias="uniqueItems")
    __properties: ClassVar[List[str]] = ["_defs", "_ref", "additionalProperties", "anyOf", "const", "default", "dependentRequired", "deprecated", "description", "enum", "examples", "exclusiveMaximum", "exclusiveMinimum", "items", "maxItems", "maxLength", "maxProperties", "maximum", "minItems", "minLength", "minProperties", "minimum", "multipleOf", "oneOf", "pattern", "prefixItems", "properties", "required", "rotateOnly", "secret", "title", "type", "uniqueItems"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of EscSchemaSchema from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # set to None if additional_properties (nullable) is None
        # and model_fields_set contains the field
        if self.additional_properties is None and "additional_properties" in self.model_fields_set:
            _dict['additionalProperties'] = None

        # set to None if const (nullable) is None
        # and model_fields_set contains the field
        if self.const is None and "const" in self.model_fields_set:
            _dict['const'] = None

        # set to None if default (nullable) is None
        # and model_fields_set contains the field
        if self.default is None and "default" in self.model_fields_set:
            _dict['default'] = None

        # set to None if items (nullable) is None
        # and model_fields_set contains the field
        if self.items is None and "items" in self.model_fields_set:
            _dict['items'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of EscSchemaSchema from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "_defs": obj.get("_defs"),
            "_ref": obj.get("_ref"),
            "additionalProperties": obj.get("additionalProperties"),
            "anyOf": obj.get("anyOf"),
            "const": obj.get("const"),
            "default": obj.get("default"),
            "dependentRequired": obj.get("dependentRequired"),
            "deprecated": obj.get("deprecated"),
            "description": obj.get("description"),
            "enum": obj.get("enum"),
            "examples": obj.get("examples"),
            "exclusiveMaximum": obj.get("exclusiveMaximum"),
            "exclusiveMinimum": obj.get("exclusiveMinimum"),
            "items": obj.get("items"),
            "maxItems": obj.get("maxItems"),
            "maxLength": obj.get("maxLength"),
            "maxProperties": obj.get("maxProperties"),
            "maximum": obj.get("maximum"),
            "minItems": obj.get("minItems"),
            "minLength": obj.get("minLength"),
            "minProperties": obj.get("minProperties"),
            "minimum": obj.get("minimum"),
            "multipleOf": obj.get("multipleOf"),
            "oneOf": obj.get("oneOf"),
            "pattern": obj.get("pattern"),
            "prefixItems": obj.get("prefixItems"),
            "properties": obj.get("properties"),
            "required": obj.get("required"),
            "rotateOnly": obj.get("rotateOnly"),
            "secret": obj.get("secret"),
            "title": obj.get("title"),
            "type": obj.get("type"),
            "uniqueItems": obj.get("uniqueItems")
        })
        return _obj


